<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Tobias Grieger &middot; Stuff I Ran Into
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="../public/css/poole.css">
  <link rel="stylesheet" href="../public/css/syntax.css">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://tbg.github.io/public/apple-touch-icon-144-precomposed.png">
                                 <link rel="shortcut icon" href="../public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="../atom.xml">
</head>

  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
     (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
       m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
         })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-56656281-1', 'auto');
    ga('send', 'pageview');

</script>


  <body>

    <div class="container content">
      <div class="masthead">
        <h3 class="masthead-title">
          <a href="../index.html" title="Home">Tobias Grieger</a>

          
              &nbsp;&nbsp;&nbsp;<small><a href="../about/index.html">About</a></small>
          
              &nbsp;&nbsp;&nbsp;<small><a href="../archive/index.html">Archive</a></small>
          
              &nbsp;&nbsp;&nbsp;<small><a href="../atom.xml">Feed</a></small>
          

        </h3>
      </div>

      <div class="posts">
  
  <div class="post">
    <h1 class="post-title">
      <a href="../single-decree-paxos-tla-compare-and-swap.html">
        Paxos on Steroids and a Crash Course in TLA+
      </a>
    </h1>

    <span class="post-date">07 Apr 2017</span>

    <p><a href="https://twitter.com/rystsov">@rystsov</a> recently posted an interesting
<a href="http://rystsov.info/2017/02/15/simple-consensus.html">article</a> in which he describes a peculiar generalization of
<a href="https://www.idi.ntnu.no/emner/tdt02/PaxosMadeSimple.pdf">Single-Decree Paxos</a> that could, in some situations, replace
<a href="https://en.wikipedia.org/wiki/Paxos_(computer_science)#Multi-Paxos">Multi-Paxos</a>. I was skeptical: this looked really useful; why wasn’t
everyone aware of it already?</p>

<p>I still don’t know the answer to that question, but I’ve since failed at
constructing a counter-example, and find that the algorithm <em>looks</em> “correct”
(more on what that means later).</p>

<p>That’s exciting! Today, embark with me on what will hopefully become a series
of posts on what (at least here) will be called <em>Compare-And-Swap Paxos</em>
(CAS-Paxos), and how to explore its properties through formal specification.</p>

<p>A reasonable first step is a tutorial-style formal description of the algorithm
in <a href="http://lamport.azurewebsites.net/tla/tla.html">TLA+</a>, which among other things is also a model checker which allows
you to specify the algorithm and explore concrete histories it permits.</p>

<p>This then, is the plan for today:</p>

<ol>
  <li><a href="index.html#review-linearizability">Quick Review of Linearizability</a></li>
  <li><a href="index.html#review-single-decree-paxos">Quick review of Single-Decree Paxos</a></li>
  <li><a href="index.html#verbal-description-of-cas-paxos">(Colloquial) Description of CAS-Paxos</a></li>
  <li><a href="index.html#specifying-cas-paxos-in-tla">Tutorial: Specifying CAS-Paxos in TLA+</a></li>
  <li><a href="index.html#discovering-interesting-histories">Tutorial: Discovering Interesting Histories</a></li>
  <li><a href="index.html#discussion-of-cas-paxos">Discussion: CAS-Paxos and its surprises</a></li>
</ol>

<h2 id="review-linearizability">Review: Linearizability</h2>

<p>We are talking about registers today (i.e. an abstract system that, no matter the
implementation, exposes and operates on a single value), so for the purpose of
making everything hands-on, imagine your system to be a distributed key-value
store with only a single active key (perhaps <a href="https://cockroachlabs.com">CockroachDB</a> or one using the
algorithm described later), and that you have multiple clients running
compare-and-swaps on that key.</p>

<p>Linearizability of that system (i.e. all the clients writing to that key) holds
if no matter how things interleave, for each operation in any possible history, you can find an instant at which it (and only it)
applied atomically, and that instant is between the moment in time at which
the respective command was initiated (i.e. a request dispatched by a client)
and acknowledged (i.e. a response received by the client).</p>

<p>For example, if the register is initially <code class="highlighter-rouge">foo</code>, and at</p>

<ul>
  <li><code class="highlighter-rouge">time=10</code>: I dispatch <code class="highlighter-rouge">CAS(bar, baz)</code></li>
  <li><code class="highlighter-rouge">time=15</code>: You dispatch <code class="highlighter-rouge">CAS(foo, bar)</code></li>
  <li><code class="highlighter-rouge">time=20</code>: I receive <code class="highlighter-rouge">OK</code> from the system</li>
  <li><code class="highlighter-rouge">time=30</code>: You receive <code class="highlighter-rouge">OK</code> from the system</li>
</ul>

<p>then that history is linearizable: my CAS succeeded, so your operation must
have applied to the system before mine; otherwise the register wouldn’t have
had the value <code class="highlighter-rouge">bar</code> I’d assumed I’d seen. And that is well possible because you
initiated your CAS before the system told me mine had applied, and so we can
arrange them atomically in a history for the system:</p>

<ul>
  <li><code class="highlighter-rouge">time=10</code>: I dispatch <code class="highlighter-rouge">CAS(bar, baz)</code></li>
  <li><code class="highlighter-rouge">time=15</code>: You dispatch <code class="highlighter-rouge">CAS(foo, bar)</code></li>
  <li><strong><code class="highlighter-rouge">time=16</code>: Server executes your <code class="highlighter-rouge">CAS(foo, bar)</code></strong></li>
  <li><strong><code class="highlighter-rouge">time=17</code>: Server executes my <code class="highlighter-rouge">CAS(bar, baz)</code></strong></li>
  <li><code class="highlighter-rouge">time=20</code>: I receive <code class="highlighter-rouge">OK</code> from the system</li>
  <li><code class="highlighter-rouge">time=30</code>: You receive <code class="highlighter-rouge">OK</code> from the system</li>
</ul>

<p><a href="https://aphyr.com/posts/313-strong-consistency-models">Kyle Kingsbury (aphyr) does a much better job</a> describing this, so you should go
there unless you’re already comfortable with the concept.</p>

<h2 id="review-single-decree-paxos">Review: Single-Decree Paxos</h2>

<p><a href="https://www.idi.ntnu.no/emner/tdt02/PaxosMadeSimple.pdf">Single-Decree Paxos</a> is a consensus algorithm that lets
a number of so-called acceptors agree on a single value (out of many that may
be offered to them) and preserve that value for eternity, unless a quorum of
acceptors holding on to a copy of the value perish, never to be seen again.</p>

<p>To clients, the abstraction provided is a linearizable register that can be written exactly
once and, once written, exposes the same value forever.</p>

<p>There are good resources for learning about Paxos <a href="https://www.idi.ntnu.no/emner/tdt02/PaxosMadeSimple.pdf">here</a> (slides
with examples!) and <a href="https://www.microsoft.com/en-us/research/publication/paxos-made-simple/">here</a> (words only), so we only review
it briefly. You absolutely want to make sure that you understand simple Paxos
well before you continue.</p>

<p>Paxos is organized around ballot (or proposal) numbers, and the goal is
generally to get successful responses from a majority of the acceptors. Clients
(“proposers”) which want to propose a (or learn the, if any) value pick
a unique proposal number (in practice, one that they think might actually
succeed) and try to take it first through a <code class="highlighter-rouge">PREPARE</code> phase and, if a majority
of acceptors indicates success, an <code class="highlighter-rouge">ACCEPT</code> phase.</p>

<p>At the end of a successful <code class="highlighter-rouge">PREPARE</code> phase, the proposer has learned from
a majority of the acceptors</p>

<ul>
  <li>that they promise to not service any smaller ballots than the proposer’s, and</li>
  <li>whether there is already a value (not necessarily committed) which must be picked
up or whether the proposer gets to choose one.</li>
</ul>

<p>If any values are returned from <code class="highlighter-rouge">PREPARE</code>, the proposer must use the value
corresponding to the highest ballot (and there are never two values for any
ballot).</p>

<p>The proposer can then proceed to the <code class="highlighter-rouge">ACCEPT</code> phase, in which it tries to store
the chosen value on all acceptors (but needs only a quorum); an acceptor will
refuse values for a ballot that it has promised not to service any more.</p>

<p>Unsuccessful proposals are usually caused by network issues, the proposer
crashing half-way through, or (most interestingly) multiple proposals
overlapping concurrently. But, no matter the interleaving, after the first
successful <code class="highlighter-rouge">ACCEPT</code> phase, the value is set in stone (barring failure of
a majority of acceptors) and all successful proposals will result in the
same value - a register backed by Single Decree Paxos is linearizable.</p>

<h2 id="verbal-description-of-cas-paxos">Verbal Description of CAS-Paxos</h2>

<p>CAS-Paxos is derived from Single Decree Paxos with just one small but impactful
change: After the <code class="highlighter-rouge">PREPARE</code> phase, the proposer is allowed to pick a new value
(perhaps taking into account the value, if any, learned from the <code class="highlighter-rouge">PREPARE</code>
phase).</p>

<p>For the purposes of this discussion, we’ll settle on that all proposers want to
run compare-and-swaps: if the value they learn is the one they expect, they go
ahead and try to get a new value accepted. To simply read the value, you run an
instance of Single-Decree Paxos instead.</p>

<p>It’s not clear at this point of the posting, but the resulting algorithm
actually seems to make basic sense (as in, it provides guarantees which are
useful), though we’ll discover a few caveats. And, though we won’t even get
close to proving it today (and I haven’t proved it), the semantics of the
register, once suitably defined, should be linearizable!</p>

<p>For now, the bird-eye view: whereas before we were stuck with a write-once
register, now we seem to have something on our hands that can change value as
often as we’d like, and perhaps could serve as the building block of
a key-value store.</p>

<p>Let’s discuss the concrete behavior of the algorithm later and do some TLA+
first.</p>

<h2 id="specifying-cas-paxos-in-tla">Specifying CAS-Paxos in TLA+</h2>

<p>Don’t care about writing the spec? <a href="index.html#running-the-model">Jump straight into the
analysis</a>.</p>

<p>Don’t try to copy-paste from these examples; they’ve been formatted to fit the
screen. Instead, to follow along, head on over to the <a href="https://github.com/tschottdorf/caspaxos-tla">caspaxos-tla
repo</a>; the initial commits on the master branch track this post.</p>

<p>A TLA specification starts with a list of module imports. We’ll deal with
integers and will want to talk about the cardinality of sets, so we import</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>EXTENDS Integers, FiniteSets
</code></pre></div></div>

<p>From what I can tell, in practice you use whichever operators you find on the
internet and when it fails, realize that there is something you needed to
import, which you then add.</p>

<h3 id="constants-basic-definitions-and-assertions">Constants, Basic Definitions, and Assertions</h3>

<p>When you specify a model, you leave certain parts configurable so that you can
invoke the model checker with various settings.</p>

<p>For CAS-Paxos, we have a set of possible values the register can take, a set of
oblique acceptors for which we really only care about how many they are, and
a mutator which maps a ballot number and a value to a new value.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CONSTANT Values, Acceptors, Mutator(_, _)
</code></pre></div></div>

<p>Throughout this whole exercise, keep in mind that the state space which needs
to be explored by the model checker exponentially spirals out of control. For
example, you certainly can’t hope to check all possible histories when the
register can hold 100 different values (in fact, 10 is probably out of reach
already); I’m using 4 throughout this example simply because that finishes in 15
seconds on my machine. Note also that we don’t restrict the ballot numbers
just yet; that’s achieved later, by overriding the definition of the natural
numbers while checking the model.</p>

<p><code class="highlighter-rouge">Mutator</code> is a good approximation of how compare-and-swap’ping proposers would
choose the new values (Single-Decree Paxos corresponds to <code class="highlighter-rouge">Mutator(ballot,
foundValue) = foundValue</code>), abstracting away nondeterminism by using the ballot
number to decide on the new value. You could let the model checker generate
“real” CAS operations as well, but let’s agree that this is interesting enough,
and that it’s easy enough to extend this later.</p>

<p>Now, we define the set of all quorums. The crucial property that we need is
that any two quorums intersect nontrivially, and the <code class="highlighter-rouge">ASSUME</code> command lets the
model checker verify that it holds in the concrete instances we run it for.</p>

<p>Since we’re lazy, we use the set of all majorities of acceptors as the set of
quorums. This is what you usually see in practice because it maximizes the
number of acceptors you can afford to lose.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Quorums == {
  S \in SUBSET(Acceptors) :
    Cardinality(S) &gt; Cardinality(Acceptors \ S) }

ASSUME QuorumAssumption == /\ \A Q \in Quorums : Q \subseteq Acceptors
                           /\ \A Q1, Q2 \in Quorums : Q1 \cap Q2 # {}
</code></pre></div></div>

<p>What this does is express that</p>

<ul>
  <li><code class="highlighter-rouge">Quorums</code> is the set of those sets of acceptors for which more acceptors are in
the set than not. That’s just a fancy way of collecting all subsets 
containing more than half of everyone.</li>
  <li><code class="highlighter-rouge">QuorumAssumption</code> has to be true or the model checker aborts. It is
satisfied if:
    <ul>
      <li>all the quorums we declared actually consist of acceptors (something that
you probably implicitly assumed anyway), and</li>
      <li>any two sets of quorums have nonempty intersection.</li>
    </ul>
  </li>
</ul>

<p>On to ballot numbers, for which we define</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Ballot == Nat
</code></pre></div></div>

<p>This just means that we define a set <code class="highlighter-rouge">Ballots</code> which equals the natural numbers
0, 1, …. As mentioned earlier, when we run the model, we’re going to override
<code class="highlighter-rouge">Nat</code> by some finite subset, typically restricting it to <code class="highlighter-rouge">1, 2, 3</code> - that’s
tiny, but enough to find an interesting history without waiting.</p>

<h3 id="messages">Messages</h3>

<p>Now we define the set of all possible messages. In this specification,
proposers are implicit. Messages originating from them are created “out of thin
air” and not addressed to a specific acceptor. In practice they would be,
though note that each acceptor would receive the same “message body”, and
omitting the explicit originator and recipient reduces the state space. Note
also that messages are not explicitly rejected but simply not reacted to. In
particular, the implicit proposer has no notion of which ballot to try next.
The spec lets them try arbitrary ballots instead. Bad for the state space, but
good for generality.</p>

<p>A message is either a prepare request for a ballot, a prepare response, an
accept request for a ballot with a new value, or an accept response.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Message ==      [type : {"prepare-req"}, bal : Ballot]
           \cup [
                 type : {"prepare-rsp"}, acc : Acceptors,
                 \* ballot for which promise is given
                 promised : Ballot,
                 \* ballot at which val was accepted
                 accepted : Ballot,
                 val : Values
                ]
           \cup [type : {"accept-req"}, bal : Ballot, newVal : Values]
           \cup [type : {"accept-rsp"}, acc : Acceptors,
                 accepted : Ballot ]
</code></pre></div></div>

<p>Above, <code class="highlighter-rouge">\cup</code> is the union of two sets, {<code class="highlighter-rouge">"prepare-req"</code>} is a set containing
as its only element the string <code class="highlighter-rouge">prepare-req</code>, and <code class="highlighter-rouge">[ x : X, y : Y ]</code> is the set
of all records (TLAs version of associative arrays) with only keys <code class="highlighter-rouge">x</code> and <code class="highlighter-rouge">y</code>
set and their values elements of <code class="highlighter-rouge">X</code>, <code class="highlighter-rouge">Y</code>, respectively.</p>

<h3 id="state-of-the-model">State of the Model</h3>

<p>Since we are modelling only the acceptors and messages, the state of the mode
is only the set of messages in existence, and whatever local state each
acceptor stores:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>VARIABLE prepared,
         accepted,
         value
VARIABLE msgs
</code></pre></div></div>

<p>The tuple <code class="highlighter-rouge">&lt;&lt;prepared[a], accepted[a], value[a]&gt;&gt;</code> will be the state that would
be kept on acceptor <code class="highlighter-rouge">a</code> in a real-world implementation of the spec.</p>

<p>The above says awefully little about what these variables are actually like in
practice, so we add a formula which we later instruct the model checker to
verify in each state, namely that <code class="highlighter-rouge">prepared</code> and <code class="highlighter-rouge">accepted</code> map acceptors to
ballot numbers, <code class="highlighter-rouge">value</code> maps acceptors to values, and that any message sent is
an element of the above set of “legal” messages.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>TypeOK == /\ prepared \in [ Acceptors -&gt; Ballot ]
          /\ accepted \in [ Acceptors -&gt; Ballot ]
          /\ value \in    [ Acceptors -&gt; Values ]
          /\ msgs \subseteq Message
</code></pre></div></div>

<p>How does one “send” a message, then? Like this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Send(m) == msgs' = msgs \cup {m}
</code></pre></div></div>
<p>TLA models the “next state” with primed variables, so to satisfy the formula
<code class="highlighter-rouge">Send(m)</code>, the next state’s incarnation of <code class="highlighter-rouge">msgs</code> must contain <code class="highlighter-rouge">m</code>.</p>

<p>We won’t ever remove messages from <code class="highlighter-rouge">msgs</code>. By modelling <code class="highlighter-rouge">msgs</code> as a set that
never shrinks, we model that messages may be received multiple times, and that
they can freely reorder. Desirable properties to model because even though
TCP/IP connections don’t allow reordering, sometimes we need to reconnect and
no such property holds across connections!</p>

<p>Now, finally, things get interesting and we get to specify the initial state of
the model:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Init == /\ prepared = [ a \in Acceptors |-&gt; 0 ]
        /\ accepted = [ a \in Acceptors |-&gt; 0 ]
        /\ value    = [ a \in Acceptors |-&gt; InitialValue ]
        /\ msgs = {}
</code></pre></div></div>

<p>Ok, maybe not too interesting. Note however that the initial state has an
initial committed value, ie the register doesn’t start “empty”.  This is an
inconsequential simplification.</p>

<h3 id="stub-actions">Stub Actions</h3>

<p>Before we write down the actions that drive the algorithm (i.e. sending and
reacting to messages), we want to finish up the scaffolding. We define mock
actions (actions are just formulas which contain primed variables, meaning that
to satisfy them you must mutate the state):</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>PrepareReq(b) == FALSE
PrepareRsp(a) == FALSE
AcceptReq(b, v) == FALSE
AcceptRsp(a) == FALSE
</code></pre></div></div>

<p>We’ll return to those later.</p>

<h3 id="the-main-formula">The Main Formula</h3>

<p>Now, finally, we reach the centerpiece of the whole operation: The <code class="highlighter-rouge">Next</code>
formula, traditionally named such because it is this formula that we’ll
instruct the model checker to satisfy by deriving new reachable states.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Next == \/ \E b \in Ballot : \/ PrepareReq(b)
                             \/ \E v \in Values : AcceptReq(b, v)
        \/ \E a \in Acceptors : PrepareRsp(a) \/ AcceptRsp(a)
</code></pre></div></div>

<p>Read: Satisfy <code class="highlighter-rouge">Next</code> by either satisfying <code class="highlighter-rouge">PrepareReq</code> for some ballot, or
<code class="highlighter-rouge">AcceptReq</code> for some ballot and value, or by finding an acceptor for which
<code class="highlighter-rouge">PrepareRsp</code> or <code class="highlighter-rouge">AcceptRsp</code> can be satisfied.</p>

<p><code class="highlighter-rouge">Next</code> is just a name without formal meaning, but <code class="highlighter-rouge">Spec</code> is the default entry
point for the TLA+ model checker. The below formula is a temporal formula and
means that the valid behaviors of the specification are those which initially
satisfy <code class="highlighter-rouge">Init</code>, and from each step to the following the formula <code class="highlighter-rouge">Next</code> is
satisfied, or all the variables stay the same (“stuttering step”).</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Spec == Init /\ [][Next]_&lt;&lt;prepared, accepted, value, msgs&gt;&gt;
</code></pre></div></div>

<p>Now hopefully it is at least somewhat clear how the model checker works: it
constructs all states that satisfy <code class="highlighter-rouge">Init</code> (there could be many, though here
there’s just one), and until it runs out of new states explores all state
transitions that satisfy <code class="highlighter-rouge">Next</code>. Phew! You can imagine how quickly the state
space blows up as you increase the size of the parameters, and hopefully it’s
also clear that any infinite set is likely going to lead to an infinite state
space!</p>

<h3 id="running-the-model-checker">Running the Model Checker</h3>

<p>As a last deed in this section, we give the model checker something to actually
check (as of now, it would construct all behaviors, but not check anything
about them). Since we’re not ready to check anything meaningful, we just assert
<code class="highlighter-rouge">TypeOK</code>; we’ll add something else later.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DesiredProperties == TypeOK
</code></pre></div></div>

<p>There’s no real point, but now you can try out the model. If you clone <a href="https://github.com/tschottdorf/caspaxos-tla">the
repo</a> and check out the <a href="https://github.com/tschottdorf/caspaxos-tla/commit/5bcac1e38a9521cc4a939103611786fd675d6ac7">right commit</a>, you’ll
find a prepared model along with the TLA file we’ve assembled so far.</p>

<p>Open the model using the <a href="http://lamport.azurewebsites.net/tla/toolbox.html">TLA toolbox</a> (<code class="highlighter-rouge">File -&gt; Open Spec -&gt; Add New
Spec</code>), and note how we declared <code class="highlighter-rouge">Acceptors</code> as a set of three “model values”;
a model value is a value that’s completely opaque to the model checker, and not
equal to any other value. We also have <code class="highlighter-rouge">Values = {0, 1, 2, 3}</code>, and <code class="highlighter-rouge">Mutator(b,
v)</code> is set to `(1</p>
<ul>
  <li>b*v) % 4` (an arbitrary choice).</li>
</ul>

<p>Furthermore, there is a “Definition Override” that sets <code class="highlighter-rouge">Nat</code> to <code class="highlighter-rouge">0..3</code> and we
have added <code class="highlighter-rouge">DesiredProperties</code> under <code class="highlighter-rouge">Invariants</code> so that it will be checked
for every state reachable in this model.</p>

<p>Now, click “Run”… oops, immediately errors out: “Deadlock reached”. This
happens because we stubbed out the actions and so from the initial state, there
is no way to satisfy the formula. That happening usually amounts to an error,
and the model checker checks for it by default. Time to add the actual
algorithm!</p>

<h3 id="completing-the-specification">Completing the Specification</h3>

<p>We return to the currently stubbed-out actions <code class="highlighter-rouge">PrepareReq</code>, <code class="highlighter-rouge">PrepareRsp</code>,
<code class="highlighter-rouge">AcceptReq</code>, and <code class="highlighter-rouge">AcceptRsp</code>, replacing them one by one. The result will be
<a href="https://github.com/tschottdorf/caspaxos-tla/commit/f5d70bd6540bdc1d5fb5cb553ab1a4d36186fc18">this commit</a>.</p>

<p>First up is <code class="highlighter-rouge">PrepareReq</code>, which is the message sent by a proposer when it
gets started on a new proposal (ballot).</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>BallotActive(b) == \E m \in msgs :
                        /\ m.type = "prepare-req"
                        /\ m.bal = b
PrepareReq(b) ==
    /\ ~ BallotActive(b)
    /\ Send([
                type |-&gt; "prepare-req",
                bal  |-&gt; b
           ])
    /\ UNCHANGED(&lt;&lt;prepared, accepted, value&gt;&gt;)
</code></pre></div></div>

<p>A ballot is started by sending a prepare request (with the hope that
responses will be received from a quorum). We could allow multiple
prepare requests for a single ballot, but since they are all identical
and we already model multiple-receipt for all messages, this adds only
state space complexity. So a ballot will only be prepared once in this
model.</p>

<p>More precisely, a successor (primed) state satisfies <code class="highlighter-rouge">PrepareReq(b)</code> if and only if</p>

<ul>
  <li>it’s predecessor (i.e. the unprimed variables) contain no prepare request for
ballot <code class="highlighter-rouge">b</code> (<code class="highlighter-rouge">~</code> is negation), and</li>
  <li>the primed state contains a message of type <code class="highlighter-rouge">prepare-req</code> and ballot <code class="highlighter-rouge">b</code>, and</li>
  <li>everything else is identical.</li>
</ul>

<p>The last condition may surprise you, but consider that if we omitted it, you
could create lots of nonsensical successor states by freely mutating
<code class="highlighter-rouge">prepared</code>, <code class="highlighter-rouge">accepted</code>, and <code class="highlighter-rouge">value</code>. Not what we would want!</p>

<p>Now that we’re warmed up, let’s get a bit more involved and hash out
<code class="highlighter-rouge">PrepareRsp(a)</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>PrepareRsp(a) ==
    /\ \E m \in msgs :
        /\ m.type = "prepare-req"
        /\ m.bal &gt; prepared[a]
        /\ prepared' = [prepared EXCEPT ![a] = m.bal]
        /\ Send([
                    acc      |-&gt; a,
                    type     |-&gt; "prepare-rsp",
                    promised |-&gt; m.bal,
                    accepted |-&gt; accepted[a],
                    val      |-&gt; value[a]
               ])
    /\ UNCHANGED &lt;&lt;accepted, value&gt;&gt;
</code></pre></div></div>

<p>Read: A prepare response can be sent if by an acceptor if a) a response was
demanded via a prepare request (there exists a corresponding prepare request
message) and b) the acceptor has not already prepared that or any larger
ballot.  On success, the acceptor remembers that it has prepared the new
ballot, and sends a response.</p>

<p>The odd syntax <code class="highlighter-rouge">[prepared EXCEPT ![a] = m.bal]</code> means</p>

<blockquote>
  <p>same as prepared, with the exception that when evaluated at <code class="highlighter-rouge">a</code>, return
<code class="highlighter-rouge">m.bal</code></p>
</blockquote>

<p>and nobody likes it, including its author <a href="http://lamport.azurewebsites.net/tla/tla.html">Leslie Lamport</a>.</p>

<p>Phew! Getting the hang of it yet? I hope so, because now it’s time for the big
leagues:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>AcceptReq(b, v) ==
    /\ ~ \E m \in msgs : m.type = "accept-req" /\ m.bal = b
    /\ \E Q \in Quorums :
        LET M == {m \in msgs : /\ m.type = "prepare-rsp"
                               /\ m.promised = b
                               /\ m.acc \in Q}
        IN /\ \A a \in Q : \E m \in M : m.acc = a
           /\ \E m \in M :
                /\ m.val = v
                /\ \A mm \in M : mm.accepted \leq m.accepted
    /\ LET newVal == Mutator(b, v) \* crucial difference from Paxos
       IN Send([
                type   |-&gt; "accept-req",
                bal    |-&gt; b,
                newVal |-&gt; newVal
               ])
    /\ UNCHANGED(&lt;&lt;accepted, value, prepared&gt;&gt;)
</code></pre></div></div>

<p>Read: An accept request can only be sent (i.e. fabricated from thin air)</p>

<ol>
  <li>once;</li>
  <li>if prepare responses for the ballot have been received from a quorum, and</li>
  <li>with a new value based on the most recently accepted value from the prepare
responses.</li>
</ol>

<p>It’s only here that we really deviate from Single-Decree Paxos by using
<code class="highlighter-rouge">Mutator</code>!</p>

<p>Scared of <code class="highlighter-rouge">AcceptRsp</code>? Don’t worry, that one is straightforward again.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>AcceptRsp(a) ==
    /\ \E m \in msgs :
        /\ m.type = "accept-req"
        /\ m.bal \geq prepared[a]
        /\ prepared' = [prepared EXCEPT ![a] = m.bal]
        /\ accepted' = [accepted EXCEPT ![a] = m.bal]
        /\ value'    = [value    EXCEPT ![a] = m.newVal]
        /\ Send([
                    acc      |-&gt; a,
                    type     |-&gt; "accept-rsp",
                    accepted |-&gt; m.bal
                ])
</code></pre></div></div>

<p>Read: An acceptor can reply to an accept request only if it hasn’t yet prepared
a higher ballot. Before replying, it makes sure it marks the ballot as prepared
(as the particular acceptor may not have received the associated prepare
request earlier), and updates its accepted ballot and the new value.</p>

<p>That’s it already! Try running the model again - it should take some time and
your laptop may begin radiating energy in the form of heat. On mine the state
space exploration takes around 15s and reports a total of 791370 states.</p>

<p>Of course, we’re still only running the model, not really checking it. In the
next section, we’ll add something that fails on some interesting histories.</p>

<h2 id="discovering-interesting-histories">Discovering Interesting Histories</h2>

<p>Now we have our system specified, a model and the associated sizable state
space to explore - but we don’t actually know what we’re looking for. Hence,
let’s return to the algorithm at hand. The result of this section will be <a href="https://github.com/tschottdorf/caspaxos-tla/commit/50229e7b8914d4d1f297940a4494b010377fccf8">this
commit</a>.</p>

<p>Without formalizing it too much, we should care in one way or another whether
the “mutations line up”. That is, the values that the register stores over its
(in the model, very short) lifetime should be those that <code class="highlighter-rouge">Mutator</code> creates
from their predecessors. Or, in the language of compare-and-swap, we shouldn’t
have one value stored in the register but then be able to run
a compare-and-swap that doesn’t respect this existing value.</p>

<p>Let’s try to put this in a naive formula we can then have the model checker
verify for all states. Remember that “committed” below means that the value at
the corresponding ballot has been accepted by a majority of acceptors.</p>

<blockquote>
  <p>For any committed value v’ at ballot b’ &gt; 0 and the previously committed value
v at ballot b &lt; b’, it holds that v’ = Mutator(b’, v).</p>
</blockquote>

<p>Just to be clear, that assumption is not correct and perhaps you want to take
a minute with pen and paper and figure out why not. Or, in the spirit of this
section, let the model checker tell you why it’s wrong. But first we have to
turn those words into math!</p>

<p>Taking the top-bottom approach, we add to our existing formula
<code class="highlighter-rouge">DesiredProperties</code> two to-be-defined assertions:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DesiredProperties == /\ TypeOK
                     /\ OnlyOneValuePerBallot
                     /\ MutationsLineUp
</code></pre></div></div>

<p><code class="highlighter-rouge">OnlyOneValuePerBallot</code> is easy to define; we just want to check that we never
accept conflicting values for a proposal. It’s fairly clear that that can’t
happen when you look at the algorithm, but it’s still good to have it checked:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>OnlyOneValuePerBallot == \A b \in Ballot :
                            Cardinality(ValuesAt(b)) \leq 1
</code></pre></div></div>

<p>where <code class="highlighter-rouge">ValuesAt(b)</code> are all the values for which we’ve seen accept responses
for ballot <code class="highlighter-rouge">b</code> (i.e. the value was accepted by the acceptor sending the
message):</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ValuesAt(b) == IF b = 0 THEN {InitialValue}
               ELSE { v \in Values :
                        \E m \in msgs :
                            /\ m.type     = "accept-rsp"
                            /\ m.accepted = b
                            /\ \E mm \in msgs :
                                /\ mm.type   = "accept-req"
                                /\ mm.bal    = b
                                /\ mm.newVal = v
</code></pre></div></div>

<p>Note how we had to comb through the accept requests to find the value; it’s not
sent out with the accept response since the recipient already knows it.</p>

<p>Now for the prize:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MutationsLineUp ==
    \A b \in CommittedBallots \ {0} :
        LET newVal == UnwrapSingleton(ValuesAt(b))
            prevCommitBallot == BallotCommittedBefore(b)
            oldVal == UnwrapSingleton(ValuesAt(prevCommitBallot))
        IN  newVal = Mutator(b, oldVal)
</code></pre></div></div>

<p>where <code class="highlighter-rouge">BallotCommittedBefore(b)</code> is the largest ballot less than <code class="highlighter-rouge">b</code> for which
a value was committed (= accepted by a quorum, not necessarily <code class="highlighter-rouge">b-1</code>!), and
<code class="highlighter-rouge">UnwrapSingleton</code> turns a single-element set into its only element:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>UnwrapSingleton(s) == CHOOSE v \in s : TRUE
AcceptedByQuorum(b) == \E Q \in Quorums: AcceptedBy(b) \cap Q = Q
CommittedBallots == {b \in Ballot : AcceptedByQuorum(b)} \cup {0}
BallotCommittedBefore(b) == CHOOSE c \in CommittedBallots :
                                /\ c &lt; b
                                /\ \A cc \in CommittedBallots :
                                    cc \geq b \/ cc \leq c
</code></pre></div></div>

<h3 id="running-the-model">Running the Model</h3>

<p>As before, give the model a spin - note that since we extended
<code class="highlighter-rouge">DesiredProperties</code>, the model checker is now checking more than before.</p>

<p>And, lo and behold, after working for a short while, execution stops and we see
a complaint:</p>

<blockquote>
  <p>Invariant DesiredProperties is violated.</p>
</blockquote>

<p>In such a situation you can get lucky and that message will be accompanied by
a “stack trace” that allows you to find out which part of the formula made it
fail. Alas, not this one, but we get the complete history of state transitions
and a trace exploration tool. From it we can transcribe (your actual history
may vary):</p>

<ul>
  <li>ballot one and two: prepare request sent</li>
  <li>ballot one and two, acceptor 1: prepare response sent (existing value 0)</li>
  <li>ballot one, acceptor 2: prepare response sent (existing value 0)</li>
  <li>ballot one: accept request sent for new value <code class="highlighter-rouge">1 = Mutator(one, 0)</code></li>
  <li>ballot one: acceptor 2: accept value 1</li>
  <li>ballot two: acceptor 2: <strong>prepare response sent (existing value 1)</strong></li>
  <li>ballot two: accept request sent for new value <code class="highlighter-rouge">3 = Mutator(two, 1)</code></li>
  <li>ballot two: acceptors 1 and 2: accept value 3</li>
  <li><code class="highlighter-rouge">DesiredProperties</code> is violated because <code class="highlighter-rouge">3</code> is committed, but not equal to
<code class="highlighter-rouge">0 = Mutator(zero, 0)</code>.</li>
</ul>

<p>We’ll discuss this and more in the next section.</p>

<h2 id="discussion-of-cas-paxos">Discussion of CAS-Paxos</h2>

<p>In the last section, we’ve discovered a history which violated our (naive) assumption that each committed value is born out of a mutation of a previous committed value: We run two ballots concurrently, and it just so happens that
without the first ballot ever committing, the second one gets to read its
value, base its mutation on it, and commit (by having two out of three
acceptors accept the ballot).</p>

<p>Does this mean we’ve found an anomaly, or, finally getting more precise, does
this mean we’ve found a non-linearizable history? Let’s write this history up
from the perspective of linearizability:</p>

<ul>
  <li><code class="highlighter-rouge">time=10</code>: the register is initially <code class="highlighter-rouge">foo</code> (which means that if you run an
instance of Single Decree Paxos, you learn the value <code class="highlighter-rouge">foo</code>)</li>
  <li><code class="highlighter-rouge">time=10</code>: I dispatch <code class="highlighter-rouge">CAS(bar, baz)</code></li>
  <li><code class="highlighter-rouge">time=11</code>: You dispatch <code class="highlighter-rouge">CAS(foo, bar)</code></li>
  <li><code class="highlighter-rouge">time=20</code>: I hear back that my <code class="highlighter-rouge">CAS</code> went through OK.</li>
  <li>You never hear back.</li>
</ul>

<p>Note that it doesn’t matter which of us dispatches their <code class="highlighter-rouge">CAS</code> first. What
matters is that though you never learn whether your <code class="highlighter-rouge">CAS</code> applied, it <strong>could</strong>
have applied at any point in time with <code class="highlighter-rouge">time &gt;= 11</code>! So it’s easy to invent
legal points in time at which it applied so that things make sense:</p>

<ul>
  <li><code class="highlighter-rouge">time=10</code>: I dispatch <code class="highlighter-rouge">CAS(bar, baz)</code></li>
  <li><code class="highlighter-rouge">time=11</code>: You dispatch <code class="highlighter-rouge">CAS(foo, bar)</code></li>
  <li><strong><code class="highlighter-rouge">time=12</code>: Your <code class="highlighter-rouge">CAS(foo, bar)</code> commits</strong></li>
  <li><strong><code class="highlighter-rouge">time=13</code>: My <code class="highlighter-rouge">CAS(bar, baz)</code> commits</strong></li>
  <li><code class="highlighter-rouge">time=20</code>: I hear back that my <code class="highlighter-rouge">CAS</code> went through OK.</li>
</ul>

<p>So this history is linearizable. Note however that that doesn’t prove that the
system is! All we’ve managed to show is that it’s not broken for this
particular example.</p>

<p>Looking back under the hood of how CAS-Paxos actually works, something
noteworthy <em>did</em> happen that doesn’t reflect through the lens of
linearizablity: When “my” <code class="highlighter-rouge">PREPARE</code> phase sends its first message, you had already gone ahead and got your new value <code class="highlighter-rouge">bar</code> accepted on one of the acceptors:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Values = [bar @ 1, foo @ 0, foo @ 0]     # value @ ballot
</code></pre></div></div>

<p>When you look at the system in that state from the outside, you might be
tempted to say that the register stores the value <code class="highlighter-rouge">foo</code> (after all, that’s the
value you can find on a majority). But that’s not correct! If you want to read
the value, you must run a full phase of Single Decree Paxos. And that would
either:</p>

<ul>
  <li>
    <p>talk to a majority that has <code class="highlighter-rouge">bar</code>, and have <code class="highlighter-rouge">bar</code> committed at the end:</p>

    <p><code class="highlighter-rouge">Values = [bar @ 2, bar @ 2, foo @ 0 or bar @ 2]</code></p>
  </li>
  <li>
    <p>talk to a majority that does not have <code class="highlighter-rouge">bar</code>, and commit a “newer” copy of
<code class="highlighter-rouge">foo</code> at the end:</p>

    <p><code class="highlighter-rouge">Values = [bar @ 1 or foo @ 2, foo @ 2, foo @ 2]</code></p>
  </li>
</ul>

<p>That is, until you actually go and read the register, it doesn’t necessarily “have”
a value - if in the examples below we didn’t run <code class="highlighter-rouge">ACCEPT</code>, you could contact
one majority first, and then the other, and you would get different values
though nobody else is using the system - definitely not linearizable!</p>

<p>Reading the value thus requires participating in deciding it. But it should be
possible to skip the <code class="highlighter-rouge">ACCEPT</code> phase if you receive the same ballot from all
possible acceptors (three in the above example).</p>

<p>Something similar, though less transparently, happened when my <code class="highlighter-rouge">PREPARE</code> phase
picked up your value which you had managed to get accepted at only one of the
nodes: It “implicitly” committed it when it committed its own update. And,
actually, since your partial value might have in turn been based on a previous
not-explicitly-committed value as well, that was also implicitly committed, and
so on. In a different possible outcome, I wouldn’t have found your value, and
would have implicitly made sure that it would never be visible, as if you had
never tried to write it. That, too, is legal.</p>

<p>This also gives an intuitive understanding of why CAS-Paxos should be
linearizable: the state of the system after a successful CAS based on an
uncommitted value is equivalent to one in which you “make up” accept messages
to accept that value (at its home ballot) between the main operation’s
<code class="highlighter-rouge">PREPARE</code> and <code class="highlighter-rouge">ACCEPT</code> phases. Then you only have to consider the case where
every value you see is committed, and that argument should be very similar to
that that assures that a Single Decree Paxos register never “loses”
a once-committed value.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Values = [bar @ 1, foo @ 0, foo @ 0]
Values = [bar @ 1, bar @ 1, bar @ 1] # implicit
Values = [baz @ 2, baz @ 2, foo @ 0]
</code></pre></div></div>

<h3 id="runaway-commit">Runaway Commit</h3>

<p>The fact that one proposal might pick up a previous incomplete proposal has
practical implications on the proposer running the incomplete proposal. From
its point of view, when it continues the <code class="highlighter-rouge">ACCEPT</code> phase, it will be told by
other acceptors that a conflicting proposal has superseded its own. But, it has
no way of finding out whether its value did make it into the system or whether
it was wiped out by the concurrent proposal. Paxos (CAS or Single Decree)
doesn’t fare too well when there is a lot of concurrent proposing going on
anyway, so this may not be much of an issue (and if it were, some extra state
could be kept around by the acceptors to mitigate).</p>

<h3 id="properly-failing-a-cas">Properly Failing a CAS</h3>

<p>So far, we have neglected the case in which a compare-and-swap operation fails,
and in particular that in which it fails because the “previous value” is not
the required one. Naively, you would perhaps consider the following behavior:</p>

<ul>
  <li>run a <code class="highlighter-rouge">PREPARE</code> phase and collect responses from a majority</li>
  <li>if the value with the highest ballot does not match what we expect, tell the
client the <code class="highlighter-rouge">CAS</code> failed: “I tried, but the register does not hold the value
you thought it did”.</li>
</ul>

<p>But that’s incorrect! Consider again the case of a partially committed value:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Values = [`bar` @ 1, `foo` @ 0, `foo` @ 0]
</code></pre></div></div>

<p>A <code class="highlighter-rouge">PREPARE</code> phase for <code class="highlighter-rouge">CAS(foo, boo)</code> might pick up <code class="highlighter-rouge">bar</code> as the most recent
value, the client is told that the register doesn’t hold the value <code class="highlighter-rouge">foo</code>.
But next, the client reads the register, winds up talking to the majority that
doesn’t have <code class="highlighter-rouge">bar</code>, and learns that the value is indeed <code class="highlighter-rouge">foo</code> - we’ve got
ourselves into a nonlinearizable history.</p>

<p>Instead, a CAS which finds an incompatible value after <code class="highlighter-rouge">PREPARE</code> must run an
<code class="highlighter-rouge">ACCEPT</code> phase with that incompatible value, because only when that succeeds is
it allowed to tell the client with authority that the register did not hold the
correct base value. Or, it could return a more generic error to the client
which doesn’t make any statement about the value of the register, but usually
you want a failed CAS to report the actual value of the register, and that
definitely needs the <code class="highlighter-rouge">ACCEPT</code> phase.</p>

<h2 id="summary">Summary</h2>

<p>We’ve introduced the CAS-Paxos algorithm, specified it in TLA+ and discussed
some interesting histories, phenomena, and implications on practical
implementations. Intuitively, we have seen that there is reason to believe that
CAS-Paxos provides a distributed linearizable register with compare-and-swap
semantics, which is a powerful primitive for building distributed systems.</p>


  </div>
  
</div>

<div class="pagination">
  
    <a class="pagination-item older" href="../page3/index.html">Older</a>
  
  
    
      <a class="pagination-item newer" href="../index.html">Newer</a>
    
  
</div>
<h4>Recent posts:</h4>
<ul class="posts">  
	  
	   <li>  
		   <span>29 Dec 2018</span> &raquo;  
		   <a href="../gmail-filter-inbox-zero.html">  
		   Using Gmail like Inbox (Zero)</a>  
	   </li>  
	  
	   <li>  
		   <span>07 Apr 2017</span> &raquo;  
		   <a href="../single-decree-paxos-tla-compare-and-swap.html">  
		   Paxos on Steroids and a Crash Course in TLA+</a>  
	   </li>  
	  
	   <li>  
		   <span>23 Mar 2017</span> &raquo;  
		   <a href="../if-its-not-paxos-its-probably-wrong-gryadka.html">  
		   Gryadka is not Paxos, so it's probably wrong (RETRACTED)</a>  
	   </li>  
	  
	   <li>  
		   <span>22 Jan 2017</span> &raquo;  
		   <a href="../sabbatical-linux-x64-exploits.html">  
		   Sabbatical Reading List: Linux x64 Exploits</a>  
	   </li>  
	  
	   <li>  
		   <span>20 Jan 2017</span> &raquo;  
		   <a href="../sabbatical-feynman-lectures.html">  
		   Sabbatical Reading List: The Feynman Lectures</a>  
	   </li>  
	  
</ul>


      



      <div class="footer">
        <p>
          &copy; 2018. All rights reserved.
        </p>
      </div>
    </div>

  </body>
</html>
